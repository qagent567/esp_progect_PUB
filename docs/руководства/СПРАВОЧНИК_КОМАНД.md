# 📚 AgriSwarm: Честный Справочник Команд

*98 команд с реальными примерами и ограничениями*

---

## 🎯 О Справочнике - Ваш Полный Путеводитель по CLI

Этот справочник - не просто список команд с синтаксисом. Это **живая документация**, которая объясняет не только "как" использовать каждую команду, но и "почему" она существует, какие проблемы решает и в каких ситуациях применяется. Представьте его как техническую энциклопедию, где каждая команда - это инструмент с историей и назначением.

**Философия организации справочника:**

Команды сгруппированы по функциональным областям - от базовых системных операций до сложной автоматизации. Эта структура отражает естественный путь работы с системой: сначала вы изучаете базовые команды для понимания состояния системы, затем настраиваете датчики и актуаторы, после чего переходите к автоматизации и мониторингу. Каждая категория - это логический этап освоения AgriSwarm.

**Что делает этот справочник особенным:**

- **Честность превыше всего** - мы указываем реальные ограничения и подводные камни каждой команды
- **Контекст и примеры** - не просто синтаксис, а реальные сценарии использования с объяснением вывода
- **Практическая применимость** - каждая команда связана с конкретными задачами управления системой
- **Прогрессивное изложение** - от простых команд к сложным, с постепенным наращиванием знаний

**Как пользоваться справочником:**

Если вы новичок, начните с раздела "Системные Команды" - они дают базовое понимание состояния системы. Опытные пользователи могут сразу переходить к нужным разделам через оглавление. Каждая команда содержит примеры реального вывода, что позволяет понять ожидаемый результат до выполнения.

**💡 Совет:** Держите этот справочник открытым во время работы с системой. Используйте поиск по странице (Ctrl+F) для быстрого нахождения нужной команды. Все примеры можно копировать и адаптировать под свои задачи.

---

## 🎮 Интерфейс Командной Строки

**Доступ:** Через Serial Monitor на скорости 115200 baud  
**Возможности:** История команд (↑/↓), автодополнение (TAB), цветной вывод

**⚠️ Честные ограничения:**
- **Отклик:** 50-200мс на команду (не мгновенно)
- **Ошибки ввода:** 70% кода CommandExecutor для обработки неправильных команд
- **Стабильность:** Некоторые команды могут зависнуть при проблемах с сетью
- **Только Serial:** Нет веб-интерфейса или приложения

```bash
AgriSwarm Terminal v0.3.7-bu
Введите 'help' для получения списка команд
> help
```

---

## 🔧 Системные Команды

Системные команды - это фундамент работы с AgriSwarm. Они позволяют получить базовую информацию о состоянии системы, управлять её поведением и диагностировать проблемы. Эти команды вы будете использовать чаще всего, особенно на начальных этапах работы. Они спроектированы так, чтобы быть максимально информативными и при этом не перегружать систему - каждая команда выполняется за 50-200 миллисекунд.

**Зачем нужны системные команды:**

В embedded системах, таких как ESP32, нет привычного графического интерфейса с индикаторами и панелями мониторинга. Системные команды заменяют всё это, предоставляя текстовый интерфейс для понимания того, что происходит внутри устройства. Они критически важны для отладки, мониторинга и повседневного управления.

### `help` - Справочная Система

**Назначение:** Команда `help` - это ваш первый помощник в освоении системы. Она предоставляет контекстную справку по всем доступным командам, группируя их по категориям для удобной навигации. Без неё пришлось бы держать в памяти синтаксис всех 98 команд, что практически невозможно.

**Почему это важно:** В отличие от веб-интерфейсов с подсказками, CLI требует точного знания синтаксиса. Команда `help` решает эту проблему, предоставляя встроенную документацию прямо в терминале. Это особенно ценно при работе через Serial Monitor, когда переключение между окнами неудобно.
```bash
help                    # Показать все команды
help system             # Команды категории "system"
help pin                # Команды работы с датчиками
help network           # Команды mesh-сети
help automation        # Команды автоматизации
```

**Практические примеры использования:**

```bash
# Сценарий 1: Первое знакомство с системой
> help
# Получите полный список команд, сгруппированных по категориям
# Используйте это для общего понимания возможностей системы

# Сценарий 2: Забыли синтаксис команды настройки датчика
> help pin
# Увидите все команды работы с датчиками и их параметры
# Это быстрее, чем искать в документации

# Сценарий 3: Изучаете автоматизацию
> help automation
# Получите список команд для создания правил и задач
# С кратким описанием каждой команды
```

**💡 Совет:** Команда `help` не требует подключения к сети и работает даже при проблемах с mesh. Это делает её надёжным инструментом для восстановления после сбоев.

### `status` - Состояние Системы

**Назначение:** Команда `status` - это ваша "приборная панель" системы. Она предоставляет моментальный снимок состояния всех ключевых компонентов: памяти, сети, датчиков, актуаторов, правил и задач. Это первая команда, которую вы запускаете при подключении к системе или при диагностике проблем.

**Почему это важно:** В распределённых системах, таких как mesh-сеть, состояние постоянно меняется - узлы подключаются и отключаются, датчики обновляют значения, правила срабатывают. Команда `status` агрегирует всю эту информацию в единый понятный вид, позволяя за секунды оценить здоровье системы. Без неё пришлось бы запускать десятки отдельных команд для получения той же информации.
```bash
status                  # Общий статус всех компонентов
```
**Вывод:**
```
═══════════════════════════════════════════════════════════════
🚀 СТАТУС СИСТЕМЫ AgriSwarm v0.3.7-bu
═══════════════════════════════════════════════════════════════
🔧 Система:        ✅ Работает
💾 Свободная память: 156,432 байт (30.1%)
⏱️ Время работы:    2д 14ч 23м 15с  
🌐 Mesh-сеть:       ✅ Подключено (3 узла)
📡 Node ID:         3456789123
🔌 Датчиков:        5 активных
⚡ Актуаторов:      3 доступных
📝 Правил:          2 включено
⏰ Задач:           1 активная
```

**Интерпретация вывода:**

- **Свободная память 30.1%** - это нормально для работающей системы с mesh-сетью. Если значение падает ниже 20%, стоит проверить утечки памяти командой `memory`.
- **Время работы 2д 14ч** - показывает стабильность системы. Частые перезагрузки указывают на проблемы с питанием или ошибки в коде.
- **3 узла в сети** - означает, что помимо текущего устройства подключены ещё 2 удалённых узла. Если ожидается больше, проверьте связь командой `mesh_nodes`.
- **5 активных датчиков** - все настроенные датчики работают и передают данные. Если число меньше ожидаемого, используйте `sensor_diagnose`.

**Практические сценарии:**

```bash
# Сценарий 1: Утренняя проверка системы
> status
# Быстро оцените, всё ли работает нормально
# Обратите внимание на память и количество узлов

# Сценарий 2: После добавления нового датчика
> status
# Проверьте, увеличилось ли количество активных датчиков
# Если нет - датчик настроен неправильно

# Сценарий 3: Диагностика проблем с автоматизацией
> status
# Убедитесь, что правила включены (не 0)
# Проверьте, что датчики и актуаторы доступны
```

### `memory` - Информация о Памяти

**Назначение:** Команда `memory` предоставляет детальную информацию об использовании оперативной памяти ESP32. Это критически важный инструмент для диагностики проблем со стабильностью, так как нехватка памяти - одна из главных причин зависаний и перезагрузок embedded систем.

**Почему это важно:** ESP32 имеет всего 520KB RAM, из которых около 70KB занимает mesh-сеть. Каждый датчик, правило и задача потребляют память. Команда `memory` позволяет отслеживать, сколько памяти осталось и какой наибольший непрерывный блок доступен для выделения. Фрагментация памяти (когда общая свободная память большая, но наибольший блок маленький) может привести к сбоям при попытке выделить память для новых объектов.
```bash
memory                  # Детальная информация о памяти
```
**Вывод:**
```
💾 СОСТОЯНИЕ ПАМЯТИ ESP32:
├── Общая RAM:           520,192 байт
├── Свободная RAM:       156,432 байт (30.1%)
├── Минимум свободной:   145,220 байт
├── Наибольший блок:     113,664 байт
├── Flash (всего):       4,194,304 байт (4MB)
└── Flash (свободно):    3,534,576 байт (84.3%)
```

### `uptime` - Время Работы
```bash
uptime                  # Сколько система работает без перезагрузки
```

### `reboot` - Перезагрузка
```bash
reboot                  # Перезагрузить ESP32
```

### `clear` - Очистка Экрана
```bash
clear                   # Очистить терминал
```

### `echo` - Вывод Текста
```bash
echo "Привет мир"       # Вывести текст в консоль
echo $memory            # Вывести системную переменную
```

---

## 🌡️ Управление Датчиками и Актуаторами

Датчики и актуаторы - это "руки и глаза" вашей системы автоматизации. Датчики собирают информацию об окружающей среде (температура, влажность, освещённость), а актуаторы выполняют физические действия (включают насосы, открывают клапаны, управляют освещением). Команды этого раздела позволяют настраивать, контролировать и управлять всеми подключёнными устройствами.

**Философия работы с устройствами:**

В AgriSwarm каждое устройство имеет уникальное имя (например, `temp1`, `pump1`), которое вы используете во всех командах. Это упрощает работу - вместо того чтобы помнить номера GPIO пинов, вы оперируете понятными именами. Система автоматически отслеживает состояние каждого устройства, периодически опрашивает датчики и обеспечивает безопасное управление актуаторами.

**Ключевые концепции:**

- **Локальные vs удалённые устройства** - локальные подключены к текущему ESP32, удалённые - к другим узлам mesh-сети
- **Интервал опроса** - как часто система читает значения датчика (слишком частый опрос может перегрузить систему)
- **Диапазоны значений** - минимальные и максимальные допустимые значения для валидации данных
- **Топики** - каналы mesh-сети, через которые устройства обмениваются данными

### `pin_setup` - Настройка Пинов

**Назначение:** Команда `pin_setup` - это точка входа для подключения любого датчика или актуатора к системе. Она регистрирует устройство, настраивает GPIO пин, определяет параметры опроса и интегрирует устройство в mesh-сеть. Без этой команды система не знает о существовании подключённого оборудования.

**Почему это важно:** Правильная настройка пинов критична для стабильной работы. Неправильный выбор GPIO может привести к конфликтам с внутренними системами ESP32 (например, GPIO 6-11 зарезервированы для SPI флеш-памяти). Неправильный интервал опроса может перегрузить систему или пропустить важные изменения. Команда `pin_setup` инкапсулирует всю эту сложность, предоставляя простой интерфейс для настройки.
```bash
# Температурный датчик DHT22
pin_setup temp1 DHT22 4 temperature 10 40 30000

# Датчик влажности почвы
pin_setup soil1 ANALOG_IN 36 soil_moisture 1000 3500 60000

# Реле управления насосом
pin_setup pump1 RELAY 2 pump_control

# Цифровой вход (кнопка)
pin_setup button1 DIGITAL_IN 5 button_control

# Цифровой выход (LED)
pin_setup led1 DIGITAL_OUT 23 led_control
```

**Синтаксис:**
```
pin_setup <имя> <тип> <gpio> <topic> [мин] [макс] [интервал_мс]
```

**Поддерживаемые типы:**
- `DHT11` - Датчик температуры/влажности ±2°C
- `DHT22` - Датчик температуры/влажности ±0.5°C  
- `ANALOG_IN` - Аналоговый вход 0-4095
- `DIGITAL_IN` - Цифровой вход 0/1
- `RELAY` - Реле до 10A/220V
- `DIGITAL_OUT` - Цифровой выход 0/1

### `pin_list` - Список Пинов
```bash
pin_list                # Показать все настроенные пины
pin_list sensors        # Только датчики
pin_list actuators      # Только актуаторы
pin_list local          # Только локальные устройства
pin_list remote         # Только удалённые устройства
```

### `pin_list tree` - Древовидный Вид
```bash
pin_list tree           # Показать пины в виде дерева
```
**Вывод:**
```
📊 ДЕРЕВО ВСЕХ УСТРОЙСТВ:
└── 🏠 Местные устройства (ESP32 ID: 3456789123)
    ├── 🌡️ Датчики (3)
    │   ├── temp1 (DHT22, GPIO 4) → 24.5°C
    │   ├── soil1 (ANALOG, GPIO 36) → 1250 (влажно)
    │   └── motion1 (DIGITAL, GPIO 5) → 0 (нет движения)
    ├── ⚡ Актуаторы (2)
    │   ├── pump1 (RELAY, GPIO 2) → OFF
    │   └── fan1 (RELAY, GPIO 14) → ON
└── 🌐 Удалённые устройства (2 узла)
    ├── 📡 Узел 2345678912
    │   └── valve1 (RELAY) → OFF
    └── 📡 Узел 1234567891
        └── light_sensor (ANALOG) → 2890
```

### `pin_info` - Чтение Значений
```bash
pin_info temp1          # Прочитать температуру
pin_info soil1          # Прочитать влажность почвы
pin_info all            # Прочитать все датчики
```

### `pin_set` - Управление Актуаторами
```bash
pin_set pump1 on        # Включить насос
pin_set pump1 off       # Выключить насос
pin_set fan1 on 30000   # Включить вентилятор на 30 секунд
pin_set led1 toggle     # Переключить LED
```

### 🤖 Сервоприводы (SERVO)

Сервоприводы позволяют точно позиционировать механизмы в диапазоне 0–180°. Поддерживаются плавное движение, ограничение угла и удалённое управление через mesh.

```bash
# Установить угол (локально)
servo_set gate_servo 90            # Угол 90° со скоростью по умолчанию
servo_set gate_servo 45 120        # Угол 45° со скоростью 120 (0–255)

# Информация о серво
servo_info gate_servo              # Текущий угол, диапазон, скорость, авто-detach

# Калибровка (min → max → mid)
servo_calibrate gate_servo         # Прогон серво и возврат в середину

# Mesh-управление
servo_send 123456 gate_servo 30 80 # Отправить на узел 123456 угол 30° со скоростью 80
```

Типичные ошибки:
- Имя пина не найдено: проверьте `pin_list actuators`
- Угол вне диапазона: настройте `min_angle`/`max_angle` при `pin_setup`
- Дёргание/перезагрузки: проверьте питание сервопривода (см. безопасность)

### `pin_delete` - Удаление Пинов
```bash
pin_delete temp1        # Удалить датчик temp1
pin_delete_all sensors  # Удалить все датчики
pin_delete_all actuators # Удалить все актуаторы
```

### `pin_info` - Информация о Пине
```bash
pin_info temp1          # Подробная информация о датчике
```
**Вывод:**
```
📊 ИНФОРМАЦИЯ О ПИНЕ 'temp1':
├── Тип: DHT22 (температурный датчик)
├── GPIO: 4
├── Топик: greenhouse/temperature
├── Интервал опроса: 30000 мс (30 сек)
├── Диапазон: 10.0°C - 40.0°C
├── Текущее значение: 24.5°C
├── Последнее обновление: 2 сек назад
├── Статус: ✅ Активен
└── Счетчик ошибок: 0
```

---

## 🌐 Mesh-Сеть

Mesh-сеть - это сердце распределённой архитектуры AgriSwarm. Она позволяет нескольким ESP32 устройствам работать как единая система, обмениваясь данными датчиков и командами управления. Команды этого раздела предоставляют инструменты для мониторинга состояния сети, диагностики проблем со связью и оптимизации производительности.

**Как работает mesh-сеть:**

Представьте mesh-сеть как группу людей, которые передают сообщения друг другу. Если один человек не может напрямую достучаться до другого, сообщение передаётся через промежуточных участников. Так же работает и mesh - если два узла находятся далеко друг от друга, данные маршрутизируются через промежуточные узлы. Это обеспечивает надёжность - выход из строя одного узла не разрушает всю сеть.

**Ключевые метрики сети:**

- **RSSI (Received Signal Strength Indicator)** - сила сигнала в dBm. Значения от -30 до -50 dBm отличные, от -50 до -70 dBm хорошие, ниже -70 dBm проблемные.
- **Время отклика (ping)** - как быстро узел отвечает на запросы. Нормальные значения 20-50ms, выше 100ms указывают на проблемы.
- **Количество узлов** - сколько устройств активно в сети. Mesh-сеть ESP32 поддерживает до 10 узлов стабильно.

**Почему mesh, а не обычный WiFi:**

Mesh-сеть не требует роутера или точки доступа - узлы соединяются напрямую друг с другом. Это критично для применений в теплицах, полях или удалённых локациях, где нет инфраструктуры WiFi. Кроме того, mesh обеспечивает автоматическое восстановление при выходе узлов из строя.

### `mesh_nodes` - Узлы Сети

**Назначение:** Команда `mesh_nodes` показывает все активные узлы в mesh-сети с их статусом, силой сигнала и временем последней связи. Это основной инструмент для мониторинга топологии сети и диагностики проблем с подключением.

**Почему это важно:** В распределённой системе критически важно знать, какие узлы онлайн, а какие потеряли связь. Если удалённый датчик перестал передавать данные, первое что нужно проверить - подключён ли его узел к сети. Команда `mesh_nodes` даёт эту информацию за секунды, показывая не только статус, но и качество связи через RSSI.
```bash
mesh_nodes              # Показать все узлы в mesh-сети
```
**Вывод:**
```
🌐 УЗЛЫ MESH-СЕТИ (3 активных):
┌─────────────┬─────────────────┬─────────────┬──────────┬─────────────┐
│ Node ID     │ Имя             │ Статус      │ RSSI     │ Последняя связь │
├─────────────┼─────────────────┼─────────────┼──────────┼─────────────┤
│ 3456789123  │ Главный         │ ✅ Локальный │ -       │ -           │
│ 2345678912  │ Полив           │ ✅ Онлайн    │ -45 dBm │ 2 сек назад │
│ 1234567891  │ Освещение       │ ✅ Онлайн    │ -52 dBm │ 1 сек назад │
└─────────────┴─────────────────┴─────────────┴──────────┴─────────────┘
```

### `ping_test` - Тест Связи
```bash
ping_test               # Ping всех узлов
ping_test 2345678912    # Ping конкретного узла
```
**Вывод:**
```
📡 ТЕСТ СВЯЗИ С УЗЛАМИ:
├── Узел 2345678912: 23ms ✅
├── Узел 1234567891: 34ms ✅
└── Среднее время отклика: 28.5ms
```

### `network_status` - Статус Сети
```bash
network_status          # Детальная информация о mesh-сети
```

### `topics_list` - Топики Сети
```bash
topics_list             # Показать все топики
topics_list tree        # В виде дерева
topics_list sensors     # Только датчики
topics_list actuators   # Только актуаторы
```

### `mesh_optimize` - Оптимизация Сети
```bash
mesh_optimize speed     # Оптимизация для скорости
mesh_optimize stability # Оптимизация для стабильности
mesh_optimize balance   # Баланс скорости и стабильности
mesh_optimize auto      # Автоматическая оптимизация
mesh_optimize status    # Текущие настройки оптимизации
```

---

## 🤖 Автоматизация

Автоматизация - это то, ради чего создаётся система умного управления. Правила автоматизации позволяют системе самостоятельно принимать решения на основе данных датчиков, без вашего участия. Команды этого раздела предоставляют инструменты для создания, управления и мониторинга правил, которые превращают пассивную систему мониторинга в активную систему управления.

**Философия автоматизации в AgriSwarm:**

Правила в AgriSwarm следуют простой логике "если-то": ЕСЛИ условие выполнено, ТО выполнить действие. Например, "ЕСЛИ влажность почвы меньше 1500, ТО включить насос на 5 секунд". Эта простота делает правила понятными и предсказуемыми, но при этом достаточно мощными для решения большинства задач автоматизации.

**Ключевые концепции:**

- **Условие** - проверка значения датчика (больше, меньше, равно определённому порогу)
- **Действие** - команда актуатору (включить, выключить, переключить)
- **Длительность** - как долго актуатор должен оставаться в новом состоянии (опционально)
- **Счётчик срабатываний** - сколько раз правило сработало (полезно для статистики и отладки)

**Безопасность автоматизации:**

Правила выполняются локально на каждом узле, что обеспечивает работу даже при потере связи с другими узлами. Система отслеживает состояние актуаторов и предотвращает одновременное выполнение конфликтующих команд. Например, если два правила пытаются управлять одним насосом, выполняется только первое сработавшее правило.

**Почему правила, а не скрипты:**

Правила проще и безопаснее скриптов. Они имеют ограниченный синтаксис, что предотвращает ошибки программирования. Они выполняются в изолированной среде, что защищает систему от зависаний. И они потребляют минимум памяти - критично для ESP32 с ограниченными ресурсами.

### `rule_add` - Создание Правила

**Назначение:** Команда `rule_add` создаёт новое правило автоматизации, связывая датчик, условие и актуатор в единую логическую цепочку. Это основной инструмент для программирования поведения системы без написания кода.

**Почему это важно:** Без автоматизации вам пришлось бы постоянно мониторить датчики и вручную управлять актуаторами. Правила делают систему автономной - она работает 24/7, реагируя на изменения окружающей среды в реальном времени. Команда `rule_add` инкапсулирует всю сложность создания правил в простой синтаксис, доступный даже пользователям без опыта программирования.
```bash
# Простое правило
rule_add auto_water "Автоматический полив" soil1 < 1500 pump1 on

# Правило с длительностью
rule_add auto_water "Автоматический полив" soil1 < 1500 pump1 on 5000

# Сложное правило
rule_add cooling "Автоматическое охлаждение" temp1 > 28 fan1 on
```

**Синтаксис:**
```
rule_add <id> <name> <source> <condition> <value> <action> <target> [payload]
```

**Поддерживаемые условия:**
- `>` - больше
- `<` - меньше  
- `==` - равно
- `!=` - не равно
- `>=` - больше или равно
- `<=` - меньше или равно

### `rule_list` - Список Правил
```bash
rule_list               # Показать все правила
rule_list enabled       # Только включённые
rule_list disabled      # Только выключенные
```
**Вывод:**
```
📝 ПРАВИЛА АВТОМАТИЗАЦИИ (2 шт.):
┌─────────────┬─────────────────────┬─────────┬─────────────┬─────────────┐
│ ID          │ Условие → Действие  │ Статус  │ Срабатывания│ Последнее   │
├─────────────┼─────────────────────┼─────────┼─────────────┼─────────────┤
│ auto_water  │ soil1 < 1500 →      │ ✅ Вкл  │ 15 раз      │ 2 мин назад │
│             │ pump1 ON (5 сек)    │         │             │             │
├─────────────┼─────────────────────┼─────────┼─────────────┼─────────────┤
│ cooling     │ temp1 > 28 →        │ ✅ Вкл  │ 3 раза      │ 1 час назад │
│             │ fan1 ON             │         │             │             │
└─────────────┴─────────────────────┴─────────┴─────────────┴─────────────┘
```

### `rule_enable` - Управление Правилами
```bash
rule_enable auto_water on    # Включить правило
rule_enable cooling off      # Выключить правило
```

### `rule_delete` - Удаление Правил
```bash
rule_delete auto_water       # Удалить правило
rule_delete_all             # Удалить все правила (осторожно!)
```

### `rule_info` - Информация о Правиле
```bash
rule_info auto_water        # Подробности о правиле
```

### `rule_wizard` - Мастер Создания Правил
```bash
rule_wizard                 # Пошаговое создание правила
```

---

## ⏰ Планировщик Задач

Планировщик задач дополняет систему правил автоматизации, добавляя временное измерение. Если правила реагируют на события ("когда температура превысит порог"), то задачи выполняются по расписанию ("каждый день в 7:00 утра"). Команды этого раздела позволяют создавать, управлять и мониторить задачи, которые выполняются в определённое время или с определённой периодичностью.

**Зачем нужен планировщик:**

Многие задачи автоматизации привязаны ко времени, а не к событиям. Например, включение освещения в теплице на рассвете, полив растений каждые 12 часов, или сбор статистики раз в час. Планировщик задач решает эти сценарии, предоставляя надёжный механизм выполнения действий по расписанию.

**Отличие от правил:**

- **Правила** - реактивные, срабатывают при изменении значений датчиков
- **Задачи** - проактивные, выполняются по времени независимо от датчиков

Часто задачи и правила работают вместе: задача включает систему полива по расписанию, а правило останавливает её при достижении нужной влажности.

### `task_setup` - Создание Задачи

**Назначение:** Команда `task_setup` запускает интерактивный мастер создания задачи, который пошагово проводит вас через настройку расписания, выбор действия и параметров выполнения.

**Почему это важно:** Синтаксис задач сложнее правил, так как включает настройку времени, дней недели, повторений. Интерактивный мастер упрощает этот процесс, задавая понятные вопросы и валидируя ввод. Это предотвращает ошибки в расписании, которые могли бы привести к неправильной работе автоматизации.
```bash
task_setup                  # Мастер создания задачи
```

### `task_list` - Список Задач
```bash
task_list                   # Показать все задачи
task_list active           # Только активные
```

### `task_enable` - Управление Задачами
```bash
task_enable task1 on        # Включить задачу
task_enable task1 off       # Выключить задачу
```

### `task_delete` - Удаление Задач
```bash
task_delete task1           # Удалить задачу
```

---

## 📝 Система Логирования

Система логирования - это "чёрный ящик" AgriSwarm, который записывает всё происходящее в системе. Логи критически важны для диагностики проблем, понимания поведения системы и отладки автоматизации. Команды этого раздела позволяют управлять детализацией логирования, просматривать сообщения и фильтровать их по компонентам.

**Философия логирования:**

В embedded системах логирование - это баланс между информативностью и производительностью. Каждое сообщение лога потребляет память и время на вывод через Serial. Поэтому AgriSwarm использует уровни логирования - от минимального (только критические ошибки) до максимального (вся отладочная информация). Вы выбираете уровень в зависимости от ситуации: в продакшене используется минимальный уровень для производительности, при отладке - максимальный для детальной информации.

**Уровни логирования:**

- **Уровень 0 (Выкл)** - логи отключены, максимальная производительность
- **Уровень 1 (Ошибки)** - только критические ошибки, требующие внимания
- **Уровень 2 (Информация)** - важные события (подключение датчиков, срабатывание правил)
- **Уровень 3 (Предупреждения)** - потенциальные проблемы (низкая память, слабый сигнал)
- **Уровень 4 (Отладка)** - вся детальная информация, включая внутренние операции

**Буфер логов:**

Система хранит последние 100 сообщений в кольцевом буфере в памяти. Это позволяет просматривать историю событий даже после их возникновения. При переполнении буфера старые сообщения удаляются, освобождая место для новых.

### `loglevel` - Уровень Детализации

**Назначение:** Команда `loglevel` устанавливает уровень детализации логирования, определяя какие сообщения будут выводиться в Serial Monitor.

**Почему это важно:** Правильный уровень логирования критичен для эффективной работы. Слишком высокий уровень (4) перегружает Serial Monitor потоком сообщений, затрудняя поиск важной информации и замедляя систему. Слишком низкий уровень (0-1) может скрыть важные предупреждения и затруднить диагностику проблем. Команда `loglevel` позволяет динамически менять детализацию без перезагрузки системы.
```bash
loglevel 0                  # Без логов
loglevel 1                  # Только ошибки
loglevel 2                  # Информация
loglevel 3                  # Предупреждения
loglevel 4                  # Отладка (максимум)
```

### `messages` - Просмотр Логов
```bash
messages                    # Последние 10 сообщений
messages 50                 # Последние 50 сообщений
messages all                # Все сообщения в буфере
messages PinManager         # Только от компонента PinManager
```

### `colors` - Управление Цветами
```bash
colors on                   # Включить цветной вывод
colors off                  # Отключить цветной вывод
```

### `debug` - Отладочные Сообщения ESP32
```bash
debug on                    # Включить системные логи ESP32
debug off                   # Отключить системные логи ESP32
```

### `wifi_logs` - Логи WiFi
```bash
wifi_logs on                # Включить логи WiFi
wifi_logs off               # Отключить логи WiFi
```

---

## 📊 Мониторинг и Диагностика

Мониторинг и диагностика - это инструменты для поддержания здоровья системы и быстрого решения проблем. Команды этого раздела предоставляют комплексные проверки всех компонентов, детальную диагностику датчиков и статистику стабильности. Они особенно важны для превентивного обслуживания - выявления проблем до того, как они приведут к сбоям.

**Философия мониторинга:**

Хорошая система мониторинга не просто показывает текущее состояние, но и предсказывает потенциальные проблемы. AgriSwarm отслеживает тренды использования памяти, частоту ошибок датчиков, качество mesh-связи и другие метрики. Команды диагностики анализируют эти данные и предоставляют рекомендации по улучшению стабильности.

**Ключевые метрики здоровья:**

- **Память** - свободная RAM должна быть выше 20%, иначе возможны сбои
- **Датчики** - процент успешных чтений должен быть выше 95%
- **Сеть** - время отклика (ping) должно быть ниже 100ms
- **Актуаторы** - все должны быть доступны и отвечать на команды
- **Время работы** - длительная работа без перезагрузок указывает на стабильность

**Проактивный vs реактивный мониторинг:**

- **Реактивный** - запускаете диагностику когда что-то сломалось
- **Проактивный** - регулярно проверяете здоровье системы, предотвращая проблемы

Рекомендуется запускать `health_check` хотя бы раз в день для раннего выявления деградации производительности.

### `health_check` - Комплексная Диагностика

**Назначение:** Команда `health_check` выполняет комплексную проверку всех компонентов системы - памяти, сети, датчиков, актуаторов, правил и задач. Она анализирует текущее состояние, сравнивает с нормальными значениями и выдаёт общую оценку здоровья системы.

**Почему это важно:** Вместо того чтобы запускать десятки отдельных команд для проверки каждого компонента, `health_check` делает это автоматически за несколько секунд. Она не только показывает проблемы, но и оценивает их серьёзность - от "всё отлично" до "требуется немедленное внимание". Это особенно ценно для пользователей без глубоких технических знаний, которым нужна простая оценка "работает/не работает".
```bash
health_check                # Проверить всё
health_check memory         # Только память
health_check sensors        # Только датчики
health_check network        # Только сеть
```
**Вывод:**
```
🏥 КОМПЛЕКСНАЯ ПРОВЕРКА ЗДОРОВЬЯ СИСТЕМЫ:
╔═══════════════════════════════════════════════════════════════╗
║                    РЕЗУЛЬТАТЫ ДИАГНОСТИКИ                     ║
╠═══════════════════════════════════════════════════════════════╣
║ 💾 Память:           ✅ ХОРОШО (30.1% свободно)              ║
║ 🌐 Mesh-сеть:        ✅ ОТЛИЧНО (3 узла, ping 28ms)         ║
║ 🌡️ Датчики:          ✅ ХОРОШО (5/5 активны)               ║
║ ⚡ Актуаторы:        ✅ ОТЛИЧНО (3/3 доступны)             ║
║ 📝 Правила:          ✅ ХОРОШО (2 активны)                  ║
║ ⏰ Задачи:           ✅ ХОРОШО (1 активна)                  ║
║ 🔧 Система:          ✅ ОТЛИЧНО (стабильна 2д 14ч)         ║
╚═══════════════════════════════════════════════════════════════╝
🎯 ОБЩАЯ ОЦЕНКА: ✅ СИСТЕМА РАБОТАЕТ ОТЛИЧНО
```

### `sensor_diagnose` - Диагностика Датчиков
```bash
sensor_diagnose             # Диагностика всех датчиков
sensor_diagnose temp1       # Диагностика конкретного датчика
```

### `sensor_status` - Статус Датчиков
```bash
sensor_status               # Краткий статус всех датчиков
sensor_status detailed      # Подробный статус
```

### `stability` - Статистика Стабильности
```bash
stability                   # Показать статистику стабильности системы
```

### `fs_info` - Информация о Файловой Системе
```bash
fs_info                     # Информация о LittleFS
```
**Вывод:**
```
💾 ФАЙЛОВАЯ СИСТЕМА LittleFS:
├── Общий размер:     1,048,576 байт (1.0 MB)
├── Использовано:     245,760 байт (23.4%)
├── Свободно:         802,816 байт (76.6%)
├── Файлов:           12
└── Директорий:       3

📁 ОСНОВНЫЕ ФАЙЛЫ:
├── /config.json (1,234 байт)
├── /rules.json (2,456 байт)
├── /pins/ (директория с 5 файлами)
└── /tasks.json (890 байт)
```

---

## 🧙‍♂️ Интерактивные Мастера

Интерактивные мастера - это "помощники с искусственным интеллектом" AgriSwarm, которые проводят вас через сложные процессы настройки шаг за шагом. Вместо того чтобы запоминать синтаксис команд и последовательность действий, вы просто отвечаете на понятные вопросы, а мастер формирует правильные команды за вас.

**Философия мастеров:**

CLI интерфейсы мощные, но требуют знания синтаксиса. Мастера делают CLI доступным для новичков, сохраняя при этом гибкость для опытных пользователей. Они особенно полезны для редких операций, синтаксис которых легко забыть между использованиями.

**Когда использовать мастера:**

- **Первая настройка системы** - мастер `first_run` проведёт через все базовые настройки
- **Настройка нового датчика** - мастер `sensor_setup` поможет выбрать правильные параметры
- **Создание сложного правила** - мастер `automation_setup` упростит логику условий
- **Настройка mesh-сети** - мастер `network_wizard` оптимизирует параметры сети

**Преимущества мастеров:**

- **Валидация ввода** - мастер проверяет корректность данных на каждом шаге
- **Контекстные подсказки** - объяснения что означает каждый параметр
- **Предотвращение ошибок** - невозможно ввести некорректную конфигурацию
- **Обучение** - мастер показывает итоговую команду, обучая синтаксису

### `wizard` - Мастера Настройки

**Назначение:** Команда `wizard` показывает список всех доступных интерактивных мастеров и запускает выбранный мастер для пошаговой настройки системы.

**Почему это важно:** Первая настройка системы может быть пугающей - нужно настроить mesh-сеть, добавить датчики, создать правила. Мастера превращают этот процесс в серию простых вопросов и ответов. Они особенно ценны для новичков, которые ещё не знакомы с командами, но хотят быстро начать работу.
```bash
wizard                      # Показать доступные мастера
wizard first_run           # Мастер первичной настройки
wizard sensor_setup        # Мастер настройки датчиков
wizard automation_setup    # Мастер создания правил
```

### `network_wizard` - Мастер Сети
```bash
network_wizard              # Пошаговая настройка mesh-сети
```

### `examples` - Примеры Команд
```bash
examples                    # Показать примеры основных команд
examples pin_setup         # Примеры настройки датчиков
examples rules             # Примеры правил автоматизации
```

---

## 🔧 Системное Управление

Системное управление включает команды для работы с конфигурацией системы - просмотра настроек, создания резервных копий и сброса к заводским значениям. Эти команды критически важны для обслуживания системы, миграции настроек между устройствами и восстановления после сбоев.

**Философия управления конфигурацией:**

Вся конфигурация AgriSwarm хранится в файловой системе LittleFS на флеш-памяти ESP32. Это означает, что настройки сохраняются даже после перезагрузки или отключения питания. Команды этого раздела предоставляют безопасный интерфейс для работы с этими файлами, предотвращая случайное повреждение конфигурации.

**Структура конфигурации:**

- **config.json** - основные настройки системы (имя узла, параметры mesh)
- **pins.json** - конфигурация всех датчиков и актуаторов
- **rules.json** - все правила автоматизации
- **tasks.json** - все задачи планировщика

**Резервное копирование:**

Регулярное создание backup критически важно, особенно перед внесением значительных изменений в конфигурацию. Backup сохраняется на флеш-память и может быть восстановлен одной командой. Рекомендуется создавать backup перед обновлением прошивки или массовым изменением настроек.

### `config_show` - Просмотр Конфигурации

**Назначение:** Команда `config_show` отображает текущие настройки системы в читаемом формате, позволяя проверить конфигурацию без редактирования файлов напрямую.

**Почему это важно:** Конфигурационные файлы хранятся в JSON формате, который не всегда удобен для чтения. Команда `config_show` форматирует эти данные в понятный вид, группируя связанные настройки и добавляя пояснения. Это особенно полезно при диагностике проблем - вы можете быстро проверить, правильно ли настроены параметры mesh-сети или WiFi.
```bash
config_show                 # Показать основные настройки
config_show mesh           # Настройки mesh-сети
config_show wifi           # Настройки WiFi
```

### `config_backup` - Резервное Копирование
```bash
config_backup              # Создать backup всех настроек
config_restore             # Восстановить из backup
```

### `config_reset` - Сброс Настроек
```bash
config_reset pins          # Сбросить настройки пинов
config_reset rules         # Сбросить правила
config_reset all           # Полный сброс (осторожно!)
```

---

## 💡 Полезные Команды

Этот раздел содержит дополнительные команды, которые не вписываются в основные категории, но предоставляют полезную функциональность для повседневной работы с системой. Они упрощают рутинные операции, предоставляют быстрый доступ к часто используемой информации и помогают поддерживать здоровье mesh-сети.

**Философия "полезных" команд:**

Эти команды созданы на основе реального опыта использования AgriSwarm. Каждая из них решает конкретную практическую задачу, которая возникает в повседневной работе. Например, `quick_status` даёт моментальный снимок системы без детальной информации - идеально для быстрой проверки. `send_heartbeat` позволяет вручную "пропинговать" сеть, что полезно при отладке проблем со связью.

### `sysinfo` - Системная Информация

**Назначение:** Команда `sysinfo` предоставляет детальную техническую информацию о ESP32 устройстве - модель чипа, частоту процессора, размер памяти, версию SDK и другие характеристики железа.

**Почему это важно:** При диагностике проблем или обращении за поддержкой часто требуется знать точные характеристики устройства. Команда `sysinfo` собирает всю эту информацию в одном месте. Она также полезна для проверки совместимости - некоторые функции могут работать по-разному на разных моделях ESP32.
```bash
sysinfo                     # Детальная информация о системе
```

### `quick_status` - Быстрый Статус
```bash
quick_status                # Краткая сводка состояния
```

### `subscriptions_health` - Здоровье Подписок
```bash
subscriptions_health        # Проверить состояние подписок на топики
```

### `send_heartbeat` - Отправка Heartbeat
```bash
send_heartbeat             # Принудительно отправить heartbeat в сеть
```

---

## 🎯 Советы по Использованию

### 🔍 Поиск Команд
```bash
help | grep pin            # Найти все команды с "pin"
help | grep mesh           # Найти все mesh команды
```

### ⌨️ Горячие Клавиши
- **↑/↓** - Навигация по истории команд
- **TAB** - Автодополнение имён команд и параметров
- **Ctrl+C** - Прервать выполнение команды

### 📋 Последовательности Команд
```bash
# Быстрая настройка системы
wizard first_run
pin_setup temp1 DHT22 4 temperature 15 30 30000
pin_setup pump1 RELAY 2 pump_control
rule_add auto_water "Автоматический полив" temp1 > 30 pump1 on 5000
status

# Диагностика проблем
health_check
sensor_diagnose
mesh_nodes
ping_test
messages 20
```

### 🎨 Цветовая Схема
- **🟢 Зелёный** - Успешные операции, нормальные значения
- **🟡 Жёлтый** - Предупреждения, пограничные значения
- **🔴 Красный** - Ошибки, критические состояния
- **🔵 Синий** - Информационные сообщения
- **⚪ Белый** - Нейтральные данные

---

**📚 Справка по Синтаксису:**
- `<обязательный_параметр>` - должен быть указан
- `[необязательный_параметр]` - можно не указывать
- `параметр1|параметр2` - выберите один из вариантов
- `...` - можно указать несколько значений

**💡 Совет:** Используйте `help <команда>` для получения подробной справки по любой команде!

---

## 🎓 Заключение - Мастерство работы с CLI

Освоение командного интерфейса AgriSwarm - это путь от новичка, который запускает команды по инструкции, до эксперта, который интуитивно понимает логику системы и может диагностировать проблемы за минуты. Этот справочник - ваш спутник на этом пути.

**Рекомендуемая траектория обучения:**

1. **Неделя 1: Базовые команды** - освойте `status`, `help`, `memory`, `mesh_nodes`. Запускайте их ежедневно, чтобы привыкнуть к интерфейсу.

2. **Неделя 2: Датчики и актуаторы** - настройте первые устройства через `pin_setup`, научитесь читать значения через `pin_info` и управлять через `pin_set`.

3. **Неделя 3: Автоматизация** - создайте первые правила через `rule_add`, наблюдайте за их срабатыванием через `rule_list`.

4. **Неделя 4: Мониторинг** - освойте `health_check`, `sensor_diagnose`, `messages` для проактивного обслуживания.

**Типичные сценарии использования:**

**Сценарий 1: Утренняя проверка системы (2 минуты)**
```bash
> status                    # Общий статус
> health_check             # Комплексная диагностика
> mesh_nodes               # Проверка сети
> sensor_status            # Состояние датчиков
```

**Сценарий 2: Добавление нового датчика (5 минут)**
```bash
> wizard sensor_setup      # Интерактивная настройка
# ИЛИ вручную:
> pin_setup temp2 DHT22 5 temperature 10 40 30000
> pin_info temp2           # Проверка работы и детальная информация
```

**Сценарий 3: Диагностика проблемы с автоматизацией (10 минут)**
```bash
> rule_list                # Проверить статус правил
> sensor_diagnose soil1    # Диагностика датчика
> pin_info soil1           # Текущее значение
> messages 50              # Просмотр логов
> loglevel 4               # Включить детальные логи
# Подождать срабатывания правила
> loglevel 2               # Вернуть нормальный уровень
```

**Сценарий 4: Подготовка к обновлению прошивки (3 минуты)**
```bash
> config_backup            # Создать backup
> config_show              # Проверить настройки
> pin_list                 # Сохранить список устройств
> rule_list                # Сохранить список правил
# Теперь можно безопасно обновлять прошивку
```

**Частые ошибки и как их избежать:**

❌ **Ошибка:** Забыли имя датчика для команды `pin_info`  
✅ **Решение:** Используйте `pin_list` или `pin_list tree` для просмотра всех устройств

❌ **Ошибка:** Правило не срабатывает  
✅ **Решение:** Проверьте `rule_list` (включено ли?), `sensor_diagnose` (работает ли датчик?), `messages` (есть ли ошибки?)

❌ **Ошибка:** Система зависает после добавления нескольких датчиков  
✅ **Решение:** Проверьте `memory` - возможно нехватка RAM. Увеличьте интервалы опроса датчиков.

❌ **Ошибка:** Удалённый датчик не отвечает  
✅ **Решение:** Проверьте `mesh_nodes` (узел онлайн?), `ping_test` (качество связи?), `network_status` (параметры сети?)

**Продвинутые техники:**

**Техника 1: Цепочки команд для комплексной диагностики**
```bash
> status && health_check && sensor_status detailed
# Выполнит все три команды последовательно
```

**Техника 2: Фильтрация логов по компоненту**
```bash
> messages PinManager      # Только логи датчиков
> messages NetworkManager  # Только логи сети
> messages RuleEngine      # Только логи автоматизации
```

**Техника 3: Использование истории команд**
```bash
# Нажмите ↑ для повтора последней команды
# Нажмите ↑↑↑ для команды 3 шага назад
# Отредактируйте и нажмите Enter
```

**Техника 4: Автодополнение для ускорения ввода**
```bash
> pin_s<TAB>              # Автодополнит до pin_setup
> pin_setup temp<TAB>     # Покажет варианты: temp1, temp2, temp3
```

**Философия эффективной работы с CLI:**

Хороший оператор CLI не запоминает все команды наизусть - он понимает логику системы и знает где искать информацию. Используйте `help` как справочник, `status` как отправную точку, `messages` как детектив для расследования проблем. Со временем вы выработаете свои паттерны работы, которые будут эффективнее любых GUI интерфейсов.

**Следующие шаги:**

После освоения команд из этого справочника рекомендуем изучить:
- **[Руководство по отладке](../../отладка/ТИПИЧНЫЕ_ПРОБЛЕМЫ.md)** - решение типичных проблем
- **[Руководство по оптимизации](../../инструкции/РУКОВОДСТВО_ПО_ОПТИМИЗАЦИИ_ПРОИЗВОДИТЕЛЬНОСТИ.md)** - повышение производительности
- **[Примеры автоматизации](../../примеры/УМНЫЙ_ДОМ.md)** - готовые сценарии использования

**Помните:** CLI - это не препятствие, а мощный инструмент. Каждая команда даёт вам прямой контроль над системой, недоступный в упрощённых GUI интерфейсах. Инвестируйте время в освоение CLI, и вы получите полный контроль над AgriSwarm!


